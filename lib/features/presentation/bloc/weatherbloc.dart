import 'package:bloc/bloc.dart';
import 'package:flutter/foundation.dart';
import 'package:flutterweather/features/data/model/autogenerated.dart';
import 'package:flutterweather/features/domain/repository/repo.dart';

import 'weatherstate.dart';
import 'weatherevent.dart';
// class WeatherBloc extends Bloc<WeatherEvent, WeatherState> {
//   final WeatherRepository repository;

//   WeatherBloc(this.repository) : super(WeatherInitial()) {
//     on<FetchWeatherEvent>((event, emit) async {
//       emit(WeatherLoading());
//       try {
//         final data = await repository.fetchWeather();

//         emit(WeatherLoaded(data.weather ?? []));
//       } catch (e) {
//         emit(WeatherError(e.toString()));
//       }
//     });
//   }
// }

class WeatherBloc extends Bloc<WeatherEvent, WeatherState> {
  final WeatherRepository repository;

  WeatherBloc(this.repository) : super(WeatherInitial()) {
    on<FetchWeatherEvent>((event, emit) async {
      // Emit loading state with current cities and search query
      emit(
        WeatherLoading(
          cities: state.cities,
          searchQuery: state.searchQuery,
          hoverStates: state.hoverStates,
        ),
      );

      try {
        final data = await repository.fetchWeather(event.location);

        // Check if city already exists
        final areaName =
            data.nearestArea?.isNotEmpty == true &&
                data.nearestArea!.first.areaName != null &&
                data.nearestArea!.first.areaName!.isNotEmpty
            ? data.nearestArea!.first.areaName!.first.value
            : null;

        final currentCities = List<Autogenerated>.from(state.cities);

        if (areaName != null) {
          // Remove duplicate if exists
          currentCities.removeWhere((existingData) {
            if (existingData.nearestArea == null ||
                existingData.nearestArea!.isEmpty)
              return false;
            final existingArea =
                existingData.nearestArea!.first.areaName != null &&
                    existingData.nearestArea!.first.areaName!.isNotEmpty
                ? existingData.nearestArea!.first.areaName!.first.value
                : null;
            return existingArea == areaName;
          });

          // Add new city
          currentCities.add(data);
        }

        // Emit loaded state with current cities and search query
        emit(
          WeatherLoaded(
            data,
            cities: currentCities,
            searchQuery: state.searchQuery,
            hoverStates: state.hoverStates,
          ),
        );
      } catch (e) {
        emit(
          WeatherError(
            e.toString(),
            cities: state.cities,
            searchQuery: state.searchQuery,
            hoverStates: state.hoverStates,
          ),
        );
      }
    });

    on<ClearCitiesEvent>((event, emit) {
      emit(
        WeatherInitial(
          cities: [],
          searchQuery: state.searchQuery,
          hoverStates: state.hoverStates,
        ),
      );
    });

    on<SearchQueryChangedEvent>((event, emit) {
      // Update search query while preserving current state
      if (state is WeatherLoaded) {
        emit(
          WeatherLoaded(
            (state as WeatherLoaded).data,
            cities: state.cities,
            searchQuery: event.query,
            hoverStates: state.hoverStates,
          ),
        );
      } else if (state is WeatherLoading) {
        emit(
          WeatherLoading(
            cities: state.cities,
            searchQuery: event.query,
            hoverStates: state.hoverStates,
          ),
        );
      } else if (state is WeatherError) {
        emit(
          WeatherError(
            (state as WeatherError).message,
            cities: state.cities,
            searchQuery: event.query,
            hoverStates: state.hoverStates,
          ),
        );
      } else {
        emit(
          WeatherInitial(
            cities: state.cities,
            searchQuery: event.query,
            hoverStates: state.hoverStates,
          ),
        );
      }
    });

    on<AppPausedEvent>((event, emit) {
      debugPrint('ðŸ“± WeatherBloc: Application paused');
    });

    on<AppResumedEvent>((event, emit) {
      debugPrint('ðŸ“± WeatherBloc: Application resumed');
    });

    on<SkeletonHoverEvent>((event, emit) {
      final newHoverStates = Map<int, bool>.from(state.hoverStates);
      newHoverStates[event.index] = event.isHovered;

      if (state is WeatherLoaded) {
        emit(
          WeatherLoaded(
            (state as WeatherLoaded).data,
            cities: state.cities,
            searchQuery: state.searchQuery,
            hoverStates: newHoverStates,
          ),
        );
      } else if (state is WeatherLoading) {
        emit(
          WeatherLoading(
            cities: state.cities,
            searchQuery: state.searchQuery,
            hoverStates: newHoverStates,
          ),
        );
      } else if (state is WeatherError) {
        emit(
          WeatherError(
            (state as WeatherError).message,
            cities: state.cities,
            searchQuery: state.searchQuery,
            hoverStates: newHoverStates,
          ),
        );
      } else {
        emit(
          WeatherInitial(
            cities: state.cities,
            searchQuery: state.searchQuery,
            hoverStates: newHoverStates,
          ),
        );
      }
    });
  }
}
