import 'package:bloc/bloc.dart';
import 'package:flutterweather/features/data/model/autogenerated.dart';
import 'package:flutterweather/features/domain/repository/repo.dart';


import 'weatherstate.dart';
import 'weatherevent.dart';
// class WeatherBloc extends Bloc<WeatherEvent, WeatherState> {
//   final WeatherRepository repository;

//   WeatherBloc(this.repository) : super(WeatherInitial()) {
//     on<FetchWeatherEvent>((event, emit) async {
//       emit(WeatherLoading());
//       try {
//         final data = await repository.fetchWeather();
      
//         emit(WeatherLoaded(data.weather ?? []));
//       } catch (e) {
//         emit(WeatherError(e.toString()));
//       }
//     });
//   }
// }


class WeatherBloc extends Bloc<WeatherEvent, WeatherState> {
  final WeatherRepository repository;

  WeatherBloc(this.repository) : super(WeatherInitial()) {
    on<FetchWeatherEvent>((event, emit) async {
      // Emit loading state with current cities and search query
      emit(WeatherLoading(cities: state.cities, searchQuery: state.searchQuery));
      
      try {
        final data = await repository.fetchWeather(event.location);
        
        // Check if city already exists
        final areaName = data.nearestArea?.isNotEmpty == true &&
            data.nearestArea!.first.areaName != null &&
            data.nearestArea!.first.areaName!.isNotEmpty
            ? data.nearestArea!.first.areaName!.first.value
            : null;
        
        final currentCities = List<Autogenerated>.from(state.cities);
        
        if (areaName != null) {
          // Remove duplicate if exists
          currentCities.removeWhere((existingData) {
            if (existingData.nearestArea == null || existingData.nearestArea!.isEmpty) return false;
            final existingArea = existingData.nearestArea!.first.areaName != null &&
                existingData.nearestArea!.first.areaName!.isNotEmpty
                ? existingData.nearestArea!.first.areaName!.first.value
                : null;
            return existingArea == areaName;
          });
          
          // Add new city
          currentCities.add(data);
        }
        
        // Emit loaded state with current cities and search query
        emit(WeatherLoaded(data, cities: currentCities, searchQuery: state.searchQuery));
      } catch (e) {
        emit(WeatherError(e.toString(), cities: state.cities, searchQuery: state.searchQuery));
      }
    });
    
    on<ClearCitiesEvent>((event, emit) {
      emit(WeatherInitial(cities: [], searchQuery: state.searchQuery));
    });

    on<SearchQueryChangedEvent>((event, emit) {
      // Update search query while preserving current state
      if (state is WeatherLoaded) {
        emit(WeatherLoaded((state as WeatherLoaded).data, 
            cities: state.cities, 
            searchQuery: event.query));
      } else if (state is WeatherLoading) {
        emit(WeatherLoading(cities: state.cities, searchQuery: event.query));
      } else if (state is WeatherError) {
        emit(WeatherError((state as WeatherError).message, 
            cities: state.cities, 
            searchQuery: event.query));
      } else {
        emit(WeatherInitial(cities: state.cities, searchQuery: event.query));
      }
    });
  }
}
